% ---
% Задача: Три подружжя
% Автор: Демʼянік Катерина
% Мова програмування: Prolog
% ---
%
% Опис задачі:
% ---
% Три подружжя (h1-w1, h2-w2, h3-w3) мають переправитися через річку.
% 
% Умови:
% - Човен вміщує максимум 2 особи
% - Жодна дружина не може перебувати на березі з чужими чоловіками
%   без присутності свого чоловіка
%
% Мета:
% - Знайти послідовність переправлень, що переміщує всіх з лівого берега
%   на правий з дотриманням умов безпеки
%
% Реалізовані методи пошуку:
% ---
% 1. BFS з відвідуваними станами у вигляді списку (чистий функційний підхід)
% 2. BFS з відвідуваними станами через динамічні предикати (з побічними ефектами)
% 3. DFS з обмеженням глибини (ітеративний підхід)
%
% Особливості реалізації:
% ---
% - Канонізація станів (сортування) для уникнення дублікатів
% - Три різні стратегії запобігання циклуванню
% - Порівняльний аналіз ефективності методів
% - Детальний вивід розв''язку з покроковою візуалізацією
%
% ---

:- dynamic visited/1.

% ---
% ВИЗНАЧЕННЯ ДАНИХ
% ---

% Список всіх учасників
people([h1, h2, h3, w1, w2, w3]).

% Визначення пар (хто чий чоловік/дружина)
couple(h1, w1).
couple(h2, w2).
couple(h3, w3).

% Предикати для ідентифікації статі
husband(h1). husband(h2). husband(h3).
wife(w1). wife(w2). wife(w3).

% ---
% Визначення станів
% ---

% Початковий стан: всі на лівому березі, човен зліва
initial_state(S) :-
    people(P),
    canon_state(state(left, P, []), S).

% Цільовий стан: всі на правому березі, човен справа
goal_state(S) :-
    people(P),
    canon_state(state(right, [], P), S).

% Канонізація стану: сортування берегів для уникнення дублікатів
% Формат стану: state(ПозиціяЧовна, ЛівийБерег, ПравийБерег)
% Сортування забезпечує однозначне представлення стану
canon_state(state(Boat, L, R), state(Boat, LS, RS)) :-
    sort(L, LS),
    sort(R, RS).

% ---
% Правила безпеки
% ---

% Берег безпечний, якщо виконується одна з умов:
% 1. На березі немає жодного чоловіка (тоді дружини в безпеці)
% 2. На березі немає жодної дружини (немає кого захищати)
% 3. Для кожної дружини на березі присутній її чоловік
safe_bank(Bank) :-
    % Знаходимо всіх чоловіків на березі
    findall(H, (member(H, Bank), husband(H)), Men),
    % Знаходимо всіх дружин на березі
    findall(W, (member(W, Bank), wife(W)), Women),
    ( Men = [] ->
        % Випадок 1: немає чоловіків - безпечно
        true
    ; Women = [] ->
        % Випадок 2: немає дружин - безпечно
        true
    ; % Випадок 3: перевіряємо, що кожна дружина має свого чоловіка
      \+ (
          member(W, Bank),
          wife(W),
          couple(H, W),
          \+ member(H, Bank)
        )
    ).

% Стан безпечний, якщо обидва береги безпечні
safe_state(state(_, L, R)) :-
    safe_bank(L),
    safe_bank(R).

% ---
% ВИБІР ПАСАЖИРІВ ДЛЯ ПЕРЕПРАВЛЕННЯ
% ---

% Варіант 1: один пасажир
passengers(Bank, [P]) :-
    member(P, Bank).

% Варіант 2: два пасажири (з уникненням дублікатів через упорядкування)
passengers(Bank, [P1, P2]) :-
    select(P1, Bank, Rest),
    member(P2, Rest),
    P1 @< P2.  % Лексикографічне порівняння для уникнення повторів

% ---
% Операції над берегами
% ---

% Видалення списку людей з берега
move_list([], From, From).
move_list([P|Ps], From, To) :-
    select(P, From, From1),
    move_list(Ps, From1, To).

% Додавання списку людей до берега (з автоматичним сортуванням)
add_list(Ps, Bank, NewBank) :-
    append(Ps, Bank, Tmp),
    sort(Tmp, NewBank).

% ---
% Генерація наступних станів (переходів)
% ---

% Переправлення з лівого берега на правий
neighbor(state(left, L, R), Next) :-
    passengers(L, Ps),       % Вибираємо пасажирів
    move_list(Ps, L, L1),     % Видаляємо їх з лівого берега
    add_list(Ps, R, R1),      % Додаємо на правий берег
    canon_state(state(right, L1, R1), Next),  % Канонізуємо новий стан
    safe_state(Next).        % Перевіряємо безпеку

% Переправлення з правого берега на лівий
neighbor(state(right, L, R), Next) :-
    passengers(R, Ps),        % Вибираємо пасажирів
    move_list(Ps, R, R1),    % Видаляємо їх з правого берега
    add_list(Ps, L, L1),    % Додаємо на лівий берег
    canon_state(state(left, L1, R1), Next),   % Канонізуємо новий стан
    safe_state(Next).     % Перевіряємо безпеку

% ---
% МЕТОД 1: Пошук у ширину (BFS) з відвідуваними станами як списком
% ---
% Чистий функційний підхід без побічних ефектів.
% Visited передається як параметр через всі рекурсивні виклики.
% Переваги: детермінований, легко відстежувати логіку
% Недоліки: більше використання пам''яті для великих задач

solve_bfs(Path) :-
    initial_state(I),
    bfs_list([[I]], [I], Rev),  % Початок з черги та списку відвідуваних
    reverse(Rev, Path).

% Базовий випадок: знайшли ціль
bfs_list([[S|Rest]|_], _Visited, [S|Rest]) :-
    goal_state(G),
    S = G, !.

% Рекурсивний випадок: розширюємо чергу
bfs_list([[S|Rest]|Queue], Visited, Sol) :-
    % Генеруємо всі нові шляхи з поточного стану
    findall([N, S|Rest],
        ( neighbor(S, N),
          \+ member(N, Visited)  % Відфільтровуємо відвідувані стани
        ),
        NewPaths),
    % Витягаємо голови нових шляхів для оновлення Visited
    states_heads(NewPaths, NewStates),
    % Додаємо нові стани до списку відвідуваних
    append(Visited, NewStates, Visited1),
    % Додаємо нові шляхи в кінець черги (BFS)
    append(Queue, NewPaths, Queue1),
    % Рекурсивно продовжуємо пошук
    bfs_list(Queue1, Visited1, Sol).

% Допоміжний предикат для витягування перших елементів шляхів
states_heads([], []).
states_heads([[S|_]|Ps], [S|Ss]) :-
    states_heads(Ps, Ss).

% ---
% Метож 2: Пошук у ширину (BFS) з динамічними предикатами
% ---
% Використання dynamic visited/1 для збереження відвідуваних станів.
% Переваги: менше передачі параметрів, швидший доступ
% Недоліки: побічні ефекти, потрібна ініціалізація перед кожним запуском

% Ініціалізація: очищення всіх відвідуваних станів
init_visited :- retractall(visited(_)).

% Позначення стану як відвідуваного
mark_visited(S) :- assertz(visited(S)).

% Перевірка чи стан вже відвідувався
was_visited(S) :- visited(S).

solve_bfs_dynamic(Path) :-
    init_visited,           % Очищаємо динамічну базу
    initial_state(I),
    mark_visited(I),         % Позначаємо початковий стан
    bfs_dyn([[I]], Rev),
    reverse(Rev, Path).

% Базовий випадок: знайшли ціль
bfs_dyn([[S|Rest]|_], [S|Rest]) :-
    goal_state(G),
    S = G, !.

% Рекурсивний випадок
bfs_dyn([[S|Rest]|Queue], Sol) :-
    % Генеруємо нові шляхи, одразу позначаючи стани як відвідувані
    findall([N, S|Rest],
        ( neighbor(S, N),
          \+ was_visited(N),
          mark_visited(N)       % Побічний ефект: позначення стану
        ),
        NewPaths),
    % Додаємо нові шляхи в кінець черги
    append(Queue, NewPaths, Queue1),
    bfs_dyn(Queue1, Sol).

% ---
% Метод 3: Пошук у глибину (DFS) з обмеженням глибини
% ---
% Ітеративне заглиблення для уникнення нескінченних циклів.
% Переваги: менше пам''яті, простіша реалізація
% Недоліки: не гарантує найкоротший шлях, може бути повільнішим

solve_dfs(Path) :-
    initial_state(I),
    dfs_limited(I, [I], 30, Rev),  % Максимальна глибина 30
    reverse(Rev, Path).

% Базовий випадок: досягли цілі
dfs_limited(S, Path, _Depth, Path) :-
    goal_state(G),
    S = G, !.

% Рекурсивний випадок: заглиблюємося далі
dfs_limited(S, Path, Depth, Sol) :-
    Depth > 0,                   % Перевіряємо ліміт глибини
    neighbor(S, N),              % Генеруємо наступний стан
    \+ member(N, Path),          % Перевіряємо відсутність циклу в поточному шляху
    Depth1 is Depth - 1,
    dfs_limited(N, [N|Path], Depth1, Sol).

% ---
% Виведення результатів 
% ---

% Підрахунок кількості кроків (на 1 менше довжини шляху)
count_steps(Path, Steps) :-
    length(Path, Len),
    Steps is Len - 1.

% Друк повного розв''язку з візуалізацією кожного кроку
print_solution(Path) :-
    write('---'), nl,
    write('           РОЗВ\'ЯЗОК ЗАДАЧІ "ТРИ ПОДРУЖЖЯ"                '), nl,
    write('---'), nl, nl,
    print_path(Path, 0),
    count_steps(Path, Steps),
    nl,
    write('---'), nl,
    format('  Загальна кількість переправлень: ~w~n', [Steps]),
    write('---'), nl.

% Рекурсивний друк кожного стану
print_path([], _).
print_path([State|Rest], N) :-
    nl,
    format('---~n', []),
    format(' Крок ~w~n', [N]),
    format('---~n', []),
    print_state(State),
    N1 is N + 1,
    print_path(Rest, N1).

% Детальний друк одного стану
print_state(state(Boat, Left, Right)) :-
    format('  Позиція човна: ~15w~n', [Boat]),
    format('  Лівий берег:  ~w~n', [Left]),
    format('  Правий берег: ~w~n', [Right]).

% ---
% Порівняння методів
% ---

compare_methods :-
    nl,
    write('---'), nl,
    write('Порівняльний аналіз методів пошуку'), nl,
    write('---'), nl, nl,

    % Метод 1: BFS зі списком
    write('---'), nl,
    write('Метод 1: BFS (visited як список - чистий підхід)'), nl,
    write('---'), nl,
    statistics(runtime, [T0|_]),
    ( solve_bfs(P1) ->
        statistics(runtime, [T1|_]),
        Time1 is T1 - T0,
        count_steps(P1, S1),
        length(P1, Len1),
        format('  Час виконання:  ~w мс~n', [Time1]),
        format('  Кількість кроків: ~w~n', [S1]),
        format('  Довжина шляху:  ~w станів~n~n', [Len1])
    ; write('  Розв\'язок не знайдено'), nl, nl
    ),

    % Метод 2: BFS з динамічними предикатами
    write('---'), nl,
    write('Метод 2: BFS (dynamic visited/1 - з побічними ефектами)'), nl,
    write('---'), nl,
    statistics(runtime, [T2|_]),
    ( solve_bfs_dynamic(P2) ->
        statistics(runtime, [T3|_]),
        Time2 is T3 - T2,
        count_steps(P2, S2),
        format('  Час виконання:  ~w мс~n', [Time2]),
        format('  Кількість кроків: ~w~n', [S2]),
        length(P2, Len2),
        format('  Довжина шляху:  ~w станів~n~n', [Len2])
    ; write('  Розв\'язок не знайдено'), nl, nl
    ),

    % Метод 3: DFS з обмеженням глибини
    write('---'), nl,
    write('Метод 3: DFS (обмеження глибини - ітеративний підхід)'), nl,
    write('---'), nl,
    statistics(runtime, [T4|_]),
    ( solve_dfs(P3) ->
        statistics(runtime, [T5|_]),
        Time3 is T5 - T4,
        count_steps(P3, S3),
        format('  Час виконання:  ~w мс~n', [Time3]),
        format('  Кількість кроків: ~w~n', [S3]),
        length(P3, Len3),
        format('  Довжина шляху:  ~w станів~n', [Len3]),
        nl,
        write('  Примітка: DFS не гарантує найкоротший шлях'), nl, nl
    ; write('  Розв\'язок не знайдено (потрібно збільшити Depth)'), nl, nl
    ),

    write('---'), nl, nl.

% ---
% Швидкий запуск
% ---

% Комплексний запуск: розв''язок + порівняння методів
go :-
    nl,
    write('Задача "Три подружжя" (Jealous Husbands)'), nl,
    nl,
    solve_bfs(Path),
    print_solution(Path),
    nl,
    compare_methods,
    write('Виконання завершено успішно'), nl, nl.

% ---
% Приклади запитів
% ---
%
% 1) Знайти розв''язок методом BFS (список) та вивести його:
%    ?- solve_bfs(Path), print_solution(Path).
%
% 2) Знайти розв''язок методом BFS (dynamic) та вивести його:
%    ?- solve_bfs_dynamic(Path), print_solution(Path).
%
% 3) Знайти розв''язок методом DFS з обмеженням глибини:
%    ?- solve_dfs(Path), print_solution(Path).
%
% 4) Порівняти всі три методи:
%    ?- compare_methods.
%
% 5) Запустити повний аналіз (розв''язок + порівняння):
%    ?- go.
%
% 6) Тільки знайти шлях без виводу:
%    ?- solve_bfs(Path).
%
% 7) Перевірити конкретний стан на безпечність:
%    ?- safe_state(state(left, [h1,w1,h2], [h3,w2,w3])).
%
% ---