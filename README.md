# Three spouses – logic programming

## Автор: **Дем'янік Катерина**  


---

## Постановка задачі
Задача «Три подружжя» (Jealous Husbands Problem) — класична логічна задача на переправу через річку.
**Умова:**  
Є три подружні пари (h1-w1, h2-w2, h3-w3), які повинні переправитися з лівого берега на правий за допомогою човна.
**Обмеження:**
- Човен може перевозити не більше **двох осіб** за один раз
- **Жодна дружина не може залишатися** на березі з чужим чоловіком без присутності свого чоловіка
- Хтось має керувати човном (човен не може пливти сам)
**Мета:**  
Знайти найкоротшу послідовність переправ (11 кроків), яка задовольняє всі обмеження.

---

## Структура проєкту

```
├── three_spouses.pl      # Основна реалізація мовою Prolog (3 методи)
├── ThreeSpouses.hs       # Порівняльна реалізація мовою Haskell (BFS)
└── README.md             # Документація проєкту
```

---

## Реалізовані методи пошуку

### 1. **BFS з функційним підходом** (visited як список)
- ✓ Чистий функційний підхід без побічних ефектів
- ✓ Відвідувані стани передаються як параметр
- ✓ Гарантує найкоротший шлях
- ✗ Більше використання пам'яті

### 2. **BFS з імперативним підходом** (dynamic visited/1)
- ✓ Використання динамічної бази даних
- ✓ Швидший доступ до відвідуваних станів
- ✓ Гарантує найкоротший шлях
- ✗ Побічні ефекти, потребує ініціалізації

### 3. **DFS з обмеженням глибини**
- ✓ Мінімальне використання пам'яті
- ✓ Простіша реалізація
- ✗ НЕ гарантує найкоротший шлях
---

## Особливості реалізації

**Ключові техніки:**
- **Канонізація станів** через сортування для уникнення дублікатів
- **Три різні стратегії** управління відвідуваними станами
- **Індикатори параметрів** (+, -, ?, --) для кожного предиката
- **Аналіз мультипризначенності** предикатів
- **Детальна візуалізація** розв'язку з покроковим описом

**Структура стану:**
```prolog
state(ПозиціяЧовна, ЛівийБерег, ПравийБерег)
% Приклад: state(left, [h1,h2,h3,w1,w2,w3], [])
```

---

## Результати експериментів

**Оптимальний розв'язок:** 11 переправлень

| Метод | Час виконання | Кількість кроків | Довжина шляху |
|-------|---------------|------------------|---------------|
| BFS (список) | ~2 мс | 11 | 12 станів |
| BFS (dynamic) | ~2 мс | 11 | 12 станів |
| DFS (depth=30) | ~2 мс | 15 | 16 станів |


---

## Порівняння Prolog vs Haskell

### **Prolog**
✓ **Декларативний опис задачі** — описуємо ЩО шукаємо, а не ЯК  
✓ **Природна мультипризначенність** — один предикат генерує всі варіанти  
✓ **Автоматичний backtracking** — не потрібно явно писати пошук  
✓ **Компактний код** — ~500 рядків з документацією  
✓ **Швидше виконання** для цієї задачі (~2 мс)  

✗ Складніше налагодження backtracking  

### **Haskell**
✓ **Типова безпека** — помилки на етапі компіляції  
✓ **Чисті функції** — відсутність побічних ефектів гарантована  
✓ **Потужні структури даних** (Set, Sequence)  
✓ **Ліниві обчислення** — обчислює тільки потрібне  
 
✗ Повільніше виконання (помітна затримка)  

### **Загальний висновок**
Для задач логічного пошуку з обмеженнями **Prolog є більш природним** і компактним рішенням. Haskell дає більший контроль, але за рахунок складнішого коду.

---

## Обґрунтування відсутності CLP

**Чому НЕ використовується CLP(FD)?**

Задача "Три ревниві чоловіки" є задачею **ПОШУКУ В ПРОСТОРІ СТАНІВ**, а не задачею задоволення обмежень (CSP).

**Ключові відмінності:**

| Критерій | CSP | Наша задача |
|----------|-----|-------------|
| Мета | Знайти присвоєння змінних | Знайти послідовність дій |
| Розв'язок | Одне присвоєння {X₁=v₁, ...} | Шлях [s₀, s₁, ..., sₙ] |
| Обмеження | Статичні на значення | Динамічні в кожному стані |
| Змінні | З фіксованими доменами | Стани як комбінації |

**CLP доцільне для:**
- N-Queens (розміщення ферзів)
- Sudoku (заповнення клітинок)
- Scheduling (розподіл завдань)
- Graph Coloring (розфарбування графа)

**Для пошуку шляху:** класичні методи (BFS/DFS) є природними та ефективними.

---

## Рецензія попередніх реалізацій

**Проаналізовано відео минулих років та знайдені реалізації:**

**Недоліки знайдених рішень:**
- Складна структура даних (окремі списки для чоловіків/жінок)
- Відсутність моделювання човна як окремого стану
- Тільки один метод пошуку (BFS) без альтернатив
- Немає експериментального вимірювання часу

**Переваги поточної реалізації:**
-  Простіша структура стану з канонізацією
-  Три різні методи з порівняльним аналізом
-  Індикатори параметрів та аналіз мультипризначенності
-  Порівняння з імперативними/функційними мовами та CLP
-  Детальна документація з прикладами

---

## Рефлексивні питання

### **Що було корисним і новим?**
- Порівняння різних підходів до представлення visited
- Канонізація станів для ефективності

### **Що виявилось складним?**
- Оптимізація продуктивності без втрати читабельності
- Балансування між компактністю та зрозумілістю коду

### **Трудомісткість роботи:**
| Етап | Години |
|------|--------|
| Розробка та налагодження коду | ~40 год |
| Вивчення літератури та підготовка | ~5 год |
| Презентація та документація | ~4 год |

### **Де ще можна застосувати?**
- Інші головоломки: 8-puzzle, Tower of Hanoi, Water Jug
- Планування маршрутів роботів
- Верифікація протоколів
- Навчальні демонстрації алгоритмів пошуку
- Ігрові AI (пошук шляху в іграх)

---

## Використання штучного інтелекту

- майже не використовувався, використовувався лише для: пошуку помилок у коді (~10% часу)

**Весь основний логічний код** (предикати пошуку, правила безпеки, генерація переходів) **написано самостійно** (~100%).

---

## Приклади запитів

```prolog
% Демонстрація мультипризначенності
?- husband(X).                  % X = h1 ; h2 ; h3
?- wife(X).                     % X = w1 ; w2 ; w3
?- couple(X, Y).                % Генерує всі 3 пари
?- passengers([h1,h2], X).      % [h1] ; [h2] ; [h1,h2]

% Перевірка безпеки стану
?- safe_state(state(left, [h1,w1,h2], [h3,w2,w3])).

% Генерація сусідів
?- initial_state(S), neighbor(S, N).
```
- все інше вказано безпосередньо в коді 

---

## Джерела

1. Bratko, I. "Prolog Programming for Artificial Intelligence" — Chapter 11-12: Planning and Search
2. Nilsson, N. "Principles of Artificial Intelligence" — Chapter 2: Problem Solving
3. Clocksin, W., Mellish, C. "Programming in Prolog" — Chapter 7: More Example Programs

---